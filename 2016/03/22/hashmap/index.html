<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="对于安卓、python等技术以及生活的感悟"><title>HashMap理解 | 朱瑞雪的写字板</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HashMap理解</h1><a id="logo" href="/.">朱瑞雪的写字板</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">HashMap理解</h1><div class="post-meta">Mar 22, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>第一次实习面试的时候,小房间里面试官拿着一本本子,上来就告诉我自己是做Java的,然后问了我很多Java基础,当从HashMap如何使用到怎么实现的时候,我就两眼懵逼了,当问到安卓的Context是干什么的时候,我的内心直接被击中了。虽然写了好几个月的程序,却只停留在会用的基础上,而没去知其所以然,太脸红了。这次面试打开了我对程序语言执着研究的大门,还是菜鸟的我感觉到能问出这种问题,还如此谦虚的人真是厉害,怀抱着大神带我飞的心情,几乎热泪盈眶的我欣然带着这份offer,准备跟着大神大干一场。结果当我入职的事后才知道,大神在我来的前几天就去支付宝了…言归正传,我就整理八经研究一下这个HashMap。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap是程序编写过程中,再平常不过的一个集合类,通常通过他的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_HashMap_</div></pre></td></tr></table></figure></p>
<p>public class HashMap<k,v> extends AbstractMap<k,v> implements Map<k,v>,<br>        Cloneable, Serializable { … }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_AbstractMap_</div></pre></td></tr></table></figure></k,v></k,v></k,v></p>
<p>public abstract class AbstractMap<k,v> implements Map<k,v> { … }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">HashMap继承于AbstractMap,Map定义了键值对的映射规则。AbstractMap内部也也实现了Map接口,</div><div class="line">这是为什么嘞？难道是为了强调吗,或者是反射getInterfaces的时候能够直接获取到Map,这里不是和明白,后续再补吧。</div><div class="line">&lt;/br&gt;</div><div class="line">### 构造方法</div><div class="line"></div><div class="line">HashMap的构造方法四个</div><div class="line">== Ps: 全局变量中已经指定默认的加载因子0.75,初始容量16 ==</div></pre></td></tr></table></figure></k,v></k,v></p>
<p>public HashMap(int initialCapacity, float loadFactor)<br><!--构造一个带指定初始容量和默认加载因子(0.75)的空HashMap--><br>public HashMap(int initialCapacity) {<br>    this(initialCapacity, DEFAULT_LOAD_FACTOR);<br>}</p>
<!--构造一个具有默认初始容量(16)和默认加载因子(0.75)的空HashMap-->
<p>public HashMap() {<br>    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);<br>}</p>
<p>public HashMap(Map&lt;? extends K, ? extends V&gt; m){<br>    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,<br>        DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">殊途同归,最终都指向了第一个构造方法。嗯,我们来看一下。</div></pre></td></tr></table></figure>
<p>public HashMap(int initialCapacity, float loadFactor)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">这里有初始容量,加载因子两个参数,影响HashMap性能。</div><div class="line"></div><div class="line">_初始容量_ 是哈希表在创建时的容量。</div><div class="line"></div><div class="line">_加载因子_ 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时,通过调用rehash 方法将容量翻倍。</div><div class="line"></div><div class="line">以下内容来自百度对于他们的理解：</div><div class="line">比如说向水桶中装水,此时HashMap就是一个桶, 这个桶的容量就是加载容量,而加载因子就是你要控制向这个桶中倒的水不超过水桶容量的比例,比如加载因子是0.75 ,那么在装水的时候这个桶最多能装到3/4 处,超过这个比例时,桶会自动扩容。因此,这个桶</div><div class="line">最多能装水 = 桶的容量 * 加载因子。</div><div class="line">如果桶的容量是40,加载因子是0.75</div><div class="line">那么你的桶最多能装40*0.75 = 30的水,如果你装了30的水还想继续装水,那么就该用大一点的桶,调用rehash就是负责增加桶的容量的方法。</div><div class="line">&lt;/br&gt;</div><div class="line">### 数据结构</div><div class="line"></div><div class="line">Java中最常用的两种结构是数组和模拟指针(引用),几乎所有的数据结构都可以利用这两种来组合实现,HashMap也是如此。实际上HashMap是一个“链表散列”,网上拔取了一张结构图：</div><div class="line"></div><div class="line">![](/Users/schnee/Desktop/20131116091617994485.jpg)</div><div class="line"></div><div class="line"></div><div class="line">HashMap底层还是数组,只是数组的每一项都是一条链,initialCapacity 代表数组长度。</div><div class="line"></div><div class="line">来吧,看看构造函数的内容：</div></pre></td></tr></table></figure></p>
<pre><code>public HashMap(int initialCapacity, float loadFactor) {
   &lt;!--   初始容量必须大于或者等于0  --&gt;
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                initialCapacity);
    &lt;!--  初始容量不能 &gt; 最大容量值,HashMap的最大容量值为2^30  --&gt;
    if (initialCapacity &gt; MAXIMUM_CAPACITY) {
        initialCapacity = MAXIMUM_CAPACITY;
    } else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) {
        initialCapacity = DEFAULT_INITIAL_CAPACITY;
    }
        &lt;!--   加载因子不能小于0   --&gt;
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                loadFactor);
    threshold = initialCapacity;
    &lt;!--  这个方法留给子类重写,里面什么都没有  --&gt;
    init();    
 }
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;/br&gt;     </div><div class="line">### 存储数据</div><div class="line">数据存储用的是```put(k,v)```的方式</div></pre></td></tr></table></figure>
<p>public V put(K key, V value) {<br>    // 如果表是空的 就新建一个HashTable<br>    if (table == EMPTY_TABLE) {<br>        inflateTable(threshold);<br>    }</p>
<pre><code>// key可以是null,调用putForNullKey方法,保存null与table第一个位置中
if (key == null)
    return putForNullKey(value);
// 获取key的哈希
int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);

// 计算key hash 值在 table 数组中的位置
int i = indexFor(hash, table.length);

// 迭代找出key的位置,为了得到 value
for (HashMapEntry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {
    Object k;
    // 如果key重复了 返回老的value （所以put的结果是个object）
    if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
        V oldValue = e.value;
        e.value = value;
        e.recordAccess(this);
        return oldValue;
    }
}
// 添加一次修改
modCount++;
// 将key、value添加至i位置处 替换
addEntry(hash, key, value, i);
return null;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">殊途同归,最终都指向了第一个构造方法。嗯,我们来看一下。</div></pre></td></tr></table></figure>
<p>public HashMap(int initialCapacity, float loadFactor)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">这里有初始容量,加载因子两个参数,影响HashMap性能。</div><div class="line"></div><div class="line">_初始容量_	是哈希表在创建时的容量。</div><div class="line"></div><div class="line">_加载因子_	是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时,通过调用rehash 方法将容量翻倍。</div><div class="line"></div><div class="line">以下内容来自百度对于他们的理解：</div><div class="line">比如说向水桶中装水,此时HashMap就是一个桶, 这个桶的容量就是加载容量,而加载因子就是你要控制向这个桶中倒的水不超过水桶容量的比例,比如加载因子是0.75 ,那么在装水的时候这个桶最多能装到3/4 处,超过这个比例时,桶会自动扩容。因此,这个桶</div><div class="line">最多能装水 = 桶的容量 * 加载因子。</div><div class="line">如果桶的容量是40,加载因子是0.75</div><div class="line">那么你的桶最多能装40*0.75 = 30的水,如果你装了30的水还想继续装水,那么就该用大一点的桶,调用rehash就是负责增加桶的容量的方法。</div><div class="line">&lt;/br&gt;</div><div class="line"></div><div class="line">#### 计算哈希值的方法</div></pre></td></tr></table></figure></p>
<p>static int hash(int h) {<br>    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们知道对于HashMap的table而言,数据分布需要均匀（最好每项都只有一个元素,这样就可以直接找到）,不能太紧也不能太松,太紧会导致查询速度慢,太松则浪费空间。计算hash值后,怎么才能保证table元素分布均与呢？我们会想到取模,但是由于取模的消耗较大,HashMap是这样处理的：调用indexFor方法。</div></pre></td></tr></table></figure></p>
<p>static int indexFor(int h, int length) {<br>// assert Integer.bitCount(length) == 1 : “length must be a non-zero power of 2”;<br>        return h &amp; (length - 1);<br> }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HashMap的底层数组长度总是2的n次方,在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时,h&amp;(length - 1)就相当于对length取模,而且速度比直接取模快得多,这是HashMap在速度上的一个优化。</div><div class="line">&lt;/br&gt;</div><div class="line">### 取数据</div><div class="line">数据获取用的是```get(key)```的形式。</div></pre></td></tr></table></figure></p>
<p>public V get(Object key) {<br>    <!--key为空的情况下,内容的获取--><br>    if (key == null)<br>        return getForNullKey();<br>    Entry<k, v=""> entry = getEntry(key);<br>    return null == entry ? null : entry.getValue();<br>  }<br><!--获取方法--><br>  private V getForNullKey() {<br>          if (size == 0) {<br>              return null;<br>          }<br>          for (HashMapEntry<k, v=""> e = table[0]; e != null; e = e.next) {<br>              if (e.key == null)<br>                  return e.value;<br>          }<br>          return null;<br>      }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">还有个比较重要的方法</div></pre></td></tr></table></figure></k,></k,></p>
<p>final Entry<k, v=""> getEntry (Object key) {<br>    if (size == 0) {<br>        return null;<br>        }<br>   int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);<br>   for (HashMapEntry<k, v=""> e = table[indexFor(hash, table.length)]; e != null;<br>           e = e.next) {<br>        Object k;<br>       if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp;key.equals(k))))<br>                    return e;<br>            }<br>            return null;<br>        }<br>```</k,></k,></p>
<p>Entry是Map接口内的一个接口,他的作用就是包装一个map的节点,这个节封装了key,value,以及别的值（比如hashmap中的哈希码和next指针）,方便对Map的操作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由此看出,数据结构基础不好,看这个真费劲。明白是明白,但是真叫你一点点写出来,是想扑街的。</p>
<p>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。<br>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。<br>因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。</p>
<p>尊重原创,借鉴：<em><a href="http://www.cnblogs.com/chenssy/p/3521565.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/p/3521565.html</a></em></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/03/22/hashmap/" data-id="cj3o1cvft000516ynacqvtr1o" class="article-share-link">分享</a><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a href="/2016/09/23/第一篇文章/" class="pre">第一篇文章</a><a href="/2015/05/24/对于IPC的理解/" class="next">对于IPC的理解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/python3/" style="font-size: 15px;">python3</a> <a href="/tags/apk打包/" style="font-size: 15px;">apk打包</a> <a href="/tags/IPC机制/" style="font-size: 15px;">IPC机制</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/05/25/algo算法/">算法题练手</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/24/包体积压缩/">android包体积压缩</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/24/textview点击事件截获/">TextView设置clickspan，导致点击事件截获</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/24/gitignore配置/">android studio .gitignore配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/24/sychronise理解/">对于synchronized关键字的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/24/php环境/">php开发环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/15/Java为例理解接口/">Java为例理解接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/15/teach/">给女朋友写的python安装教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/BaseActivity里面设置标题栏/">BaseActivity里面设置标题栏</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/安卓的简单常识－（半岛版）/">安卓的简单常识－（半岛版）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://weibo.com/270955001/home" title="微博" target="_blank">微博</a><ul></ul><a href="http://www.jianshu.com/u/b08b96e401db" title="简书" target="_blank">简书</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">朱瑞雪的写字板.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>